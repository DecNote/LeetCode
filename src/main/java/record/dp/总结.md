* 279：完全平方数（完全背包）
* 300：数组的最长子序列（注意dp的设定）
* 322：零钱兑换（完全背包，凑成总金额所需的最少的硬币个数，求最少，所以要注意初始化）
* 343：整数拆分（难题）
* 377：总数组合（完全背包，排列）
* 416：分割等和子集（01背包，价值=重量，装满容量为x背包）
* 494：目标和（01背包，装满容量为x背包，有几种方法）
* 474：一和零（01背包，二维的01背包）
* 518：零钱兑换（完全背包，求兑换成给定金额的种数）


* 583：两个字符串的删除操作（两个字符串需要多少步删除才能一样，最长子序列的变形）
* 647：回文子串（二维dp，分情况讨论）
* 718：【重点】最长重复的连续子数组（dp表示以i，j结尾的...）
* 1035：同1143题
* 1049：最后一个石头的重量（01背包变形，分成和最接近的两部分）
* 1143：【重点】字符串的最长公共子序列（dp表示前i，j个...）

## 总结

* 找最长公共子序列，连续子序列，那么dp设定为以i，j结尾的...最长为`dp[i][j]`，且需求出`dp[][]`最大值
* 找最长公共子序列，非连续子序列，那么dp设定为前i，前j个的...最长为`dp[i][j]`，答案为`dp[n][n]`

***

* 背包问题，首先判断是01背包还是完全背包！！！
* 01背包经典问题：在一堆数中，选出部分使其和为bagSize，背包物品的价值和重量是1:1（相等）
* 01背包问题，每件物品仅可选1次，在有限容量下求最大价值
* 多重背包问题，每件物品可以选多次，在有限容量下也可以求最大价值
* 背包问题求装满某容量的选最少物品个数（如322题，279题），一般需要用到Math.min函数，且初始值可能除`dp[0]`外，其他需要设置为某个大值（不要设为Integer.MAX_VALUE）
* 背包问题求最大（如474），那么一般情况下，只需要注意`dp[0]`的初始化，其他`dp[x]`用默认初始化0值
* 背包问题求方案个数（如518题），dp更新公式一般都是累加，且初始化`dp[0]=1`
* 先遍历`weight`，再遍历`bagSize`，为组合；先遍历`bagSize`，再遍历`weight`，为排列






